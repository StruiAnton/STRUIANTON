#include <iostream>
#include <queue>

using namespace std;

struct Node {
	int parent;
	int value;
	int pologenie;
	int x;
	int y;
};

int h = 0;//счетчик
Node mas[1000];
queue<Node> myQueue;

int funkcia(int** a,int *x,int *y, int N, int f) {
	bool t = false;
	while (t != true) {
		if (myQueue.empty() == false && h<1000) {
			Node g = myQueue.front();
			myQueue.pop();
			mas[h] = g;
			for (int i = 0; i < N; i++) {
				if (a[g.value - 1][i] != 0) {
					if (g.pologenie == 1 && i + 1 == f && x[i] == g.x && y[i] > g.y) {
						Node f;
						f.parent = h;
						f.value = i + 1;
						h += 1;
						mas[h] = f;
						return 1;
					}
					if (g.pologenie == 1 && i + 1 == f && y[i] == g.y && x[i] > g.x) {
						Node f1;
						f1.parent = h;
						f1.value = i + 1;
						h += 1;
						mas[h] = f1;
						return 1;
					}
					if (g.pologenie == 1 && x[i] == g.x && y[i] > g.y) {
						Node g1;
						g1.parent = h;
						g1.pologenie = 1;
						g1.value = i + 1;
						g1.x = x[i];
						g1.y = y[i];
						myQueue.push(g1);
					}
					if (g.pologenie == 1 && y[i] == g.y && x[i] > g.x) {
						Node g2;
						g2.parent = h;
						g2.pologenie = 2;
						g2.value = i + 1;
						g2.x = x[i];
						g2.y = y[i];
						myQueue.push(g2);
					}
					if (g.pologenie == 2 && i + 1 == f && x[i] == g.x && g.y > y[i]) {
						Node f2;
						f2.parent = h;
						f2.value = i + 1;
						h += 1;
						mas[h] = f2;
						return 1;
					}
					if (g.pologenie == 2 && i + 1 == f && y[i] == g.y && x[i] > g.x) {
						Node f3;
						f3.parent = h;
						f3.value = i + 1;
						h += 1;
						mas[h] = f3;
						return 1;
					}
					if (g.pologenie == 2 && x[i] == g.x && g.y > y[i]) {
						Node g3;
						g3.parent = h;
						g3.pologenie = 3;
						g3.value = i + 1;
						g3.x = x[i];
						g3.y = y[i];
						myQueue.push(g3);
					}
					if (g.pologenie == 2 && y[i] == g.y && x[i] > g.x) {
						Node g4;
						g4.parent = h;
						g4.pologenie = 2;
						g4.value = i + 1;
						g4.x = x[i];
						g4.y = y[i];
						myQueue.push(g4);
					}
					if (g.pologenie == 3 && i + 1 == f && x[i] == g.x && g.y > y[i]) {
						Node f4;
						f4.parent = h;
						f4.value = i + 1;
						h += 1;
						mas[h] = f4;
						return 1;
					}
					if (g.pologenie == 3 && i + 1 == f && y[i] == g.y && g.x > x[i]) {
						Node f5;
						f5.parent = h;
						f5.value = i + 1;
						h += 1;
						mas[h] = f5;
						return 1;
					}
					if (g.pologenie == 3 && x[i] == g.x && g.y > y[i]) {
						Node g5;
						g5.parent = h;
						g5.pologenie = 3;
						g5.value = i + 1;
						g5.x = x[i];
						g5.y = y[i];
						myQueue.push(g5);
					}
					if (g.pologenie == 3 && y[i] == g.y && g.x > x[i]) {
						Node g6;
						g6.parent = h;
						g6.pologenie = 4;
						g6.value = i + 1;
						g6.x = x[i];
						g6.y = y[i];
						myQueue.push(g6);
					}
					if (g.pologenie == 4 && i + 1 == f && x[i] == g.x && y[i] > g.y) {
						Node f6;
						f6.parent = h;
						f6.value = i + 1;
						h += 1;
						mas[h] = f6;
						return 1;
					}
					if (g.pologenie == 4 && i + 1 == f && y[i] == g.y && g.x > x[i]) {
						Node f7;
						f7.parent = h;
						f7.value = i + 1;
						h += 1;
						mas[h] = f7;
						return 1;
					}
					if (g.pologenie == 4 && x[i] == g.x && y[i] > g.y) {
						Node g7;
						g7.parent = h;
						g7.pologenie = 1;
						g7.value = i + 1;
						g7.x = x[i];
						g7.y = y[i];
						myQueue.push(g7);
					}
					if (g.pologenie == 4 && y[i] == g.y && g.x > x[i]) {
						Node g8;
						g8.parent = h;
						g8.pologenie = 4;
						g8.value = i + 1;
						g8.x = x[i];
						g8.y = y[i];
						myQueue.push(g8);
					}
				}
			}
			h += 1;
		}
		else {
		t = true;
}
	}
	return 0;
}

int main() {
	setlocale(0, "");
	int N;
	int f;
	cout << "Введите колличество перекрестков" << endl;
	cin >> N;

	int** a = new int* [N];
	int* x = new int[N];
	int* y = new int[N];
	for (int i = 0; i < N; i++) {
		a[i] = new int[N];
	}
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			a[i][j] = 0;
		}
	}
	for (int i = 0; i < N; i++) {
		cout << "Введите кординаты перекрестка " << i + 1 << endl;
		int u, o;
		cin >> u;
		cin >> o;
		x[i] = u;
		y[i] = o;
	}
	for (int i = 0; i < N; i++) {
		cout << "Введите номер перекрестка соединяющего перекресток " << i + 1 << endl;
		int h = 0;
		while (h != 1) {
			cout << "Продолжить -1 закончить -2" << endl;
			int k;
			cin >> k;
			if (k == -1) {
				int y;
				cin >> y;
				a[i][y - 1] = 1;
			}
			if (k == -2) {
				h = 1;
			}
		}
	}
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			cout << a[i][j] << " ";
		}
		cout << endl;
	}
	cout << "Введите номер перекрестка S" << endl;
	int S;
	cin >> S;
	cout << "Введите номер перекрестка f" << endl;
	cin >> f;
	int S1 = S;
	int F1 = f;
	Node t;
	t.parent = 0;
	t.pologenie = 1;
	t.value = S;
	t.x = x[S - 1];
	t.y = y[S - 1];
	myQueue.push(t);
	int G=funkcia(a, x, y, N, f);
	if (G == 1) {
		bool q = false;
		while (q != true) {
			Node L = mas[h];
			if (L.value == S && L.parent==0) {
				cout << S << endl;
				q = true;  
			}
			else {
				cout << L.value << " ";
				h = L.parent;
			}
		}
	}
	if (G == 0) {
		cout << "Нельзя добраться" << endl;
	}
	delete[]a;
	delete[]x;
	delete[]y;
	return 0;
}